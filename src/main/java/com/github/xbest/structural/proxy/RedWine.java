package com.github.xbest.structural.proxy;

/**
 * 代理模式，有点类似适配器模式和装饰模式，个人觉得本身设计模式就没有一个非常固定的死设计，<br/>
 * 设计模式都需要在实际项目中灵活运用。<br/>
 * 如果非要对这三个模式做一下区分，大概有这么区别：
 * <ul>代理模式，是实现了一套完整的和被代理类一模一样的接口，但是在接口中增强了实现，如日志、安全、拦截等。</ul>
 * <ul>装饰模式，是通过对原有接口的功能增强和扩展，增加部分特色功能。</ul>
 * <ul>适配器模式，是通过对旧有接口的重新包装适配，使得新的接口符合客户端（调用者）的期望。</ul>
 * 从上面可以看出适配器模式和装饰模式更为类似，但是适配器模式解决的是原有接口不能满足新的需求，<br/>
 * 而装饰模式解决的是原有的接口功能不足，需要丰富和扩展。<br/>
 * 代理模式与适配器模式最大的区别就是，代理模式代理类和被代理类实现的是同一套接口，<br/>
 * 而适配器模式则是实现的新的接口，与被适配的对象不是同一套接口。<br/>
 * 代理模式在jdk中的典型应用就是{@link java.net.Proxy}、{@link java.lang.reflect.InvocationHandler}
 * Created by link on 2017/3/1.
 */
public interface RedWine {
    void product();

    void sell();
}
